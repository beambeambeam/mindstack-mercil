---
globs: *.ts,*.tsx
---

# TypeScript Rules

## Type Safety

- Always use explicit types instead of `any`. Use `unknown`, generics, interfaces, or inferred types.
- Use strict TypeScript settings as configured in [tsconfig.json](mdc:apps/web/tsconfig.json)
- Prefer type imports: `import type { Asset } from "../types/asset"`
- Use interfaces for object shapes, especially API responses and data models
- Always type function parameters and return types explicitly

## Type Definitions

- All types/interfaces are defined in [src/types/asset.ts](mdc:apps/web/src/types/asset.ts)
- Use Zod schemas for runtime validation (see [src/env.ts](mdc:apps/web/src/env.ts) for example)
- API response types should match backend schemas exactly

## Code Style

- Use tabs for indentation (2 spaces per tab)
- Use semicolons
- Prefer `const` over `let`, avoid `var`
- Use arrow functions for callbacks
- Use template literals for string interpolation
- Use optional chaining (`?.`) and nullish coalescing (`??`) when appropriate

## Async/Await

- Always use `async/await` instead of `.then()` chains
- Handle errors with try/catch blocks
- Use `Promise.all()` for parallel async operations
- Functions that return promises should have explicit `Promise<T>` return types

## Examples

```typescript
// Good: Explicit types, async/await, error handling
export async function getAssetById(assetId: number): Promise<Asset> {
  const url = `${API_URL}/assets/${assetId}`;
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`API Error: ${response.status}`);
  }
  return parseJsonResponse<Asset>(response, url);
}

// Bad: any types, .then() chains
export function getAssetById(assetId: any) {
  return fetch(`${API_URL}/assets/${assetId}`).then(r => r.json());
}
```
